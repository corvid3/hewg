#include <algorithm>
#include <cmath>
#include <cstdlib>
#include <exception>
#include <filesystem>
#include <jayson.hh>
#include <optional>
#include <span>
#include <stdexcept>
#include <string>
#include <sys/stat.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <thread>
#include <unistd.h>
#include <vector>

#include "analysis.hh"
#include "common.hh"
#include "compile.hh"
#include "confs.hh"
#include "paths.hh"
#include "terse.hh"

/* generated by c++gen */

// i don't want to see m'code squandered...

// auto const link_step_messages = { "now, let's get linking..." };

auto const command_arguments = std::array{
  terse::arg_parse_option{
    .longhand = "",
    .shorthand = std::nullopt,
    .takes_value = terse::arg_parse_option::TakesValue::No,
    .usage = "",
  },
};

static void
check_valid_dir()
{
  // assert that the executing directory is at the root
  // of a hewg project
  if (not std::filesystem::is_regular_file(hewg_config_path))
    throw std::runtime_error("hewg.scl not detected in current directory");

  // do a quick check that src/ exists in the first place
  if (not std::filesystem::is_directory(hewg_src_directory_path))
    throw std::runtime_error("there should be a /src directory in the root of "
                             "a hewg project, create it to proceed");
}

// ensures that a .hcache exists
static void
check_cache()
{
  if (std::filesystem::exists(hewg_cache_path)) {
    if (not std::filesystem::is_directory(hewg_cache_path))
      throw std::runtime_error(
        "hewg cache path, .hcache, should be a directory, but is not!");
  } else {
    threadsafe_print("creating cache directory\n");
    std::filesystem::create_directory(hewg_cache_path);
  }

  // these should also just always exist
  std::filesystem::create_directory(hewg_object_cache_path);
  std::filesystem::create_directory(hewg_dependency_cache_path);
}

static std::optional<std::string>
build_profile(terse::arg_parse_output const& args)
{
  // if no build profile, default to the "generic" profile
  if (args.bare.size() == 0)
    return std::nullopt;

  return std::string(args.bare.front());
}

static void
check_filename_clashes(ConfigurationFile const& conf)
{
  auto const filepaths = get_source_filepaths(conf);

  std::vector<std::filesystem::path> paths;

  for (auto b = filepaths.begin(); b != filepaths.end(); b++) {
    auto const found = std::find_if(
      b + 1, filepaths.end(), [&](std::filesystem::path const in) -> bool {
        return in.parent_path() == b->parent_path() and
               in.filename() == b->filename();
      });

    if (found != filepaths.end())
      throw std::runtime_error(std::format(
        "conflicting source filenames, {} & {}", b->string(), found->string()));
  }
}

int
main(int argc, const char** argv)
{
  try {
    // this should always be the first thing ran, never move this
    // ensures that side effects don't happen in non-hewg directories
    check_valid_dir();

    threadsafe_print("compiler master hewg starts his work...\n");

    // TODO: change this with an argument
    auto const num_threads = std::thread::hardware_concurrency();
    ThreadPool thread_pool(num_threads);

    auto const config = get_config_file();

    auto const args = terse::parse_args(argc, argv, command_arguments);
    auto const profile = build_profile(args);

    /*
      steps for compiling:
        * get a list of all of flags per file/language type

        * get a list of all source files, and sort
          them based on language type
            e.g. C, C++, source / header

        * convert the list of files
          into a list of files that require rebuilds,
          by modification date & by dependency rebuilds

        * compile each source file triggered for rebuild into object files,
          stopping compiling when an error is hit

        * if no errors occurred, link all files together into an executable
    */

    // do some quick checks...
    check_filename_clashes(config);
    check_cache();

    compile_c_cxx(thread_pool, config);

    thread_pool.block_until_finished();
  } catch (std::exception const& e) {
    threadsafe_print("ERROR: ", e.what());
    exit(1);
  }
}
