#include <algorithm>
#include <chrono>
#include <cmath>
#include <cstdlib>
#include <exception>
#include <filesystem>
#include <iostream>
#include <iterator>
#include <jayson.hh>
#include <optional>
#include <ranges>
#include <scl.hh>
#include <stdexcept>
#include <sys/stat.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <terse.hh>
#include <unistd.h>
#include <utility>
#include <variant>
#include <vector>

#include "analysis.hh"
#include "build.hh"
#include "cmdline.hh"
#include "common.hh"
#include "confs.hh"
#include "install.hh"
#include "paths.hh"
#include "thread_pool.hh"

/* generated by c++gen */

// i don't want to see m'code squandered...

// auto const link_step_messages = { "now, let's get linking..." };

static std::string
get_build_profile(std::span<std::string const> bares)
{
  if (bares.size() == 0) {
#ifdef __linux__
    return "linux";
#endif

    // TODO: implement mingw
  } else if (bares.size() == 1)
    return bares[0];
  else
    throw std::runtime_error(
      "when passing a build profile, cannot specify more than one!");
}

static void
clean(ThreadPool&,
      ConfigurationFile const&,
      CleanOptions const&,
      std::span<std::string const> bares)
{
  if (bares.size() > 0)
    throw std::runtime_error(
      "clean subcommand does not take any bare arguments!");

  if (not std::filesystem::exists(hewg_cache_path))
    return;

  std::vector<std::filesystem::path> to_clean;

  auto const delete_if_exists = [&](std::filesystem::path what) {
    if (not std::filesystem::exists(what))
      return;
    to_clean.push_back(what);
  };

  // make sure to nuke the hook cache
  delete_if_exists(hewg_hook_cache_path);
  delete_if_exists(hewg_builtinsym_cache_path);
  delete_if_exists(hewg_builtinsym_src_path);
  delete_if_exists(hewg_builtinsym_obj_path);

  delete_if_exists(hewg_c_object_cache_path);
  delete_if_exists(hewg_c_pic_object_cache_path);
  delete_if_exists(hewg_cxx_object_cache_path);
  delete_if_exists(hewg_cxx_pic_object_cache_path);

  delete_if_exists(hewg_c_dependency_cache_path);
  delete_if_exists(hewg_c_pic_dependency_cache_path);
  delete_if_exists(hewg_cxx_dependency_cache_path);
  delete_if_exists(hewg_cxx_pic_dependency_cache_path);

  if (to_clean.empty()) {
    threadsafe_print("nothing to clean!\n");
    return;
  }

  for (auto const& sf : to_clean)
    threadsafe_print(std::format("deleting: {}\n", sf.string()));

  do_terminal_countdown(5);

  for (auto const& sf : to_clean)
    std::filesystem::remove_all(sf);
}

static void
init(ThreadPool&,
     std::string_view,
     InitOptions const&,
     std::span<std::string const> bares)
{
  auto const this_dir = std::filesystem::current_path();

  if (not std::filesystem::is_empty(this_dir))
    throw std::runtime_error(
      "init command can only be ran on empty directories!");

  std::filesystem::create_directory("src");
  std::filesystem::create_directory("include");
  std::filesystem::create_directory("private");

  {
    if (bares.size() != 2)
      throw std::runtime_error(
        "init command takes two bare arguments, the first must be the type of "
        "the project and the second must be the name of the project");

    auto const type = bares[0];
    auto const name = bares[1];

    auto const project_type = project_type_from_string(type)
                                .or_else([&]() -> std::optional<ProjectType> {
                                  throw std::runtime_error(std::format(
                                    "unknown project type {}", type));
                                  std::unreachable();
                                })
                                .value();

    ConfigurationFile config;

    config.meta.type = project_type;
    config.meta.version = { 0, 0, 0 };

    config.project.version = { 0, 0, 0 };
    config.project.name = name;

    config.flags.cxx_flags = { "-Wextra", "-Werror", "-std=c++23" };
    config.flags.c_flags = { "-Wextra", "-Werror", "-std=c2y" };

    config.files.cxx = { "main.cc" };

    scl::file file;
    scl::serialize(config, file);

    std::ofstream("./hewg.scl") << file.serialize();
  }

  std::ofstream("./src/main.cc") << R"(#include<iostream>

int main() {
  std::cout << "hello, world!";    
})";
}

int
main(int argc, char** argv)
try {
  auto const [tl_options, scmds, bares] = parse_cmdline(argc, argv);

  if (tl_options.verbose_print)
    verbose_output = true;

  auto const config_path = tl_options.config_file_path.value_or("./hewg.scl");

  // TODO: change this with an argument
  threadsafe_print_verbose(
    std::format("using <{}> tasks\n", tl_options.num_tasks));
  ThreadPool thread_pool(tl_options.num_tasks);

  if (tl_options.print_version) {
    using namespace std::chrono;
    auto const dur = duration<long>(__hewg_build_date_package_hewg);
    auto const since_epoch = time_point<utc_clock, seconds>(dur);

    threadsafe_print(std::format("version <{}>\n",
                                 version_triplet_to_string(this_hewg_version)));
    threadsafe_print(std::format("built <{}> UTC\n", since_epoch));

    return 0;
  }

  if (std::holds_alternative<std::monostate>(scmds)) {
    std::cout << terse::print_usage<ToplevelOptions>() << std::endl;
  } else if (std::holds_alternative<BuildOptions>(scmds)) {
    auto options = std::get<BuildOptions>(scmds);

    if (options.help)
      std::cout << terse::print_usage<BuildOptions>() << std::endl,
        std::exit(0);

    auto const profile = get_build_profile(bares);
    ConfigurationFile const config =
      get_config_file(tl_options, config_path, profile);

    build(thread_pool, config, options, profile);
  } else if (std::holds_alternative<CleanOptions>(scmds)) {
    auto options = std::get<CleanOptions>(scmds);

    if (options.help)
      std::cout << terse::print_usage<CleanOptions>() << std::endl,
        std::exit(0);

    auto const profile = get_build_profile(bares);
    ConfigurationFile const config =
      get_config_file(tl_options, config_path, profile);

    clean(thread_pool, config, options, bares);
  } else if (std::holds_alternative<InitOptions>(scmds)) {
    auto options = std::get<InitOptions>(scmds);

    if (options.help)
      std::cout << terse::print_usage<InitOptions>() << std::endl, std::exit(0);

    init(thread_pool, config_path, options, bares);
  } else if (std::holds_alternative<InstallOptions>(scmds)) {
    auto options = std::get<InstallOptions>(scmds);

    if (options.help)
      std::cout << terse::print_usage<InstallOptions>() << std::endl,
        std::exit(0);

    auto const profile = get_build_profile(bares);
    ConfigurationFile const config =
      get_config_file(tl_options, config_path, profile);
    install(config, options, profile);
  }
} catch (std::exception const& e) {
  threadsafe_print("ERROR: ", e.what(), '\n');

  exit(1);
}
