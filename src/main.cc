#include <chrono>
#include <cmath>
#include <crow.jayson/jayson.hh>
#include <crow.scl/scl.hh>
#include <crow.terse/terse.hh>
#include <cstdlib>
#include <exception>
#include <filesystem>
#include <iostream>
#include <stdexcept>
#include <sys/stat.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>
#include <variant>
#include <vector>

#include "build.hh"
#include "cmdline.hh"
#include "common.hh"
#include "confs.hh"
#include "init.hh"
#include "install.hh"
#include "packages.hh"
#include "paths.hh"
#include "thread_pool.hh"

/* generated by c++gen */

// i don't want to see m'code squandered...

// auto const link_step_messages = { "now, let's get linking..." };

static void
clean(ThreadPool&,
      ConfigurationFile const&,
      CleanOptions const&,
      std::span<std::string const> bares)
{
  if (bares.size() > 0)
    throw std::runtime_error(
      "clean subcommand does not take any bare arguments!");

  if (not std::filesystem::exists(hewg_cache_path))
    return;

  std::vector<std::filesystem::path> to_clean;

  auto const delete_if_exists = [&](std::filesystem::path what) {
    if (not std::filesystem::exists(what))
      return;
    to_clean.push_back(what);
  };

  delete_if_exists(hewg_cache_path);

  if (to_clean.empty()) {
    threadsafe_print("nothing to clean!\n");
    return;
  }

  for (auto const& sf : to_clean)
    threadsafe_print(std::format("deleting: {}\n", sf.string()));

  do_terminal_countdown(5);

  for (auto const& sf : to_clean)
    std::filesystem::remove_all(sf);
}

int
main(int argc, char** argv)
try {
  auto const [tl_options, scmds, bares] = parse_cmdline(argc, argv);

  if (tl_options.verbose_print)
    verbose_output = true;

  skip_countdown = tl_options.skip_pause;

  auto const config_path = tl_options.config_file_path.value_or("./hewg.scl");

  // TODO: change this with an argument
  threadsafe_print_verbose(
    std::format("using <{}> tasks\n", tl_options.num_tasks));
  num_tasks = tl_options.num_tasks;
  ThreadPool thread_pool(tl_options.num_tasks);

  if (tl_options.print_version) {
    using namespace std::chrono;
    auto const dur = duration<long>(__hewg_build_date_package_hewg);
    auto const since_epoch = time_point<utc_clock, seconds>(dur);

    threadsafe_print(std::format("version <{}>\n", this_hewg_version));
    threadsafe_print(std::format("built <{}> UTC\n", since_epoch));

    return 0;
  }

  if (std::holds_alternative<std::monostate>(scmds)) {
    std::cout << terse::print_usage<ToplevelOptions>() << std::endl;
  } else if (std::holds_alternative<BuildOptions>(scmds)) {
    auto options = std::get<BuildOptions>(scmds);

    if (options.help)
      std::cout << terse::print_usage<BuildOptions>() << std::endl,
        std::exit(0);

    // install implies release
    if (options.install == true) {
      threadsafe_print_verbose("install implies --release");
      options.release = true;
    }

    ConfigurationFile const config = get_config_file(tl_options, config_path);
    auto const target_triplet =
      TargetTriplet(options.target.value_or(THIS_TARGET));
    auto const target_file = get_target_file(target_triplet);

    // build_dependency_tree(config);

    auto db = open_package_db();

    build(thread_pool, config, db, target_file, options);

    if (options.install)
      install(config, db, target_triplet, options);
  } else if (std::holds_alternative<CleanOptions>(scmds)) {
    auto options = std::get<CleanOptions>(scmds);

    if (options.help)
      std::cout << terse::print_usage<CleanOptions>() << std::endl,
        std::exit(0);

    ConfigurationFile const config = get_config_file(tl_options, config_path);

    clean(thread_pool, config, options, bares);
  } else if (std::holds_alternative<InitOptions>(scmds)) {
    auto options = std::get<InitOptions>(scmds);

    if (options.help)
      std::cout << terse::print_usage<InitOptions>() << std::endl, std::exit(0);

    init(options, bares);
  }
} catch (std::exception const& e) {
  threadsafe_print("ERROR: ", e.what(), '\n');

  exit(1);
}
